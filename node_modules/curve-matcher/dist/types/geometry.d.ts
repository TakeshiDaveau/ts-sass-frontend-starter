export interface Point {
    x: number;
    y: number;
}
export declare type Curve = Point[];
/** @hidden */
export declare const subtract: (v1: Point, v2: Point) => Point;
/**
 * Calculate the distance between 2 points
 * @param point1
 * @param point2
 */
export declare const pointDistance: (point1: Point, point2: Point) => number;
/**
 * calculate the length of the curve
 * @param points
 */
export declare const curveLength: (points: Point[]) => number;
/**
 * return a new point, p3, which is on the same line as p1 and p2, but <dist> away from p2
 * p1, p2, p3 will always lie on the line in that order (as long as dist is positive)
 * @param p1
 * @param p2
 * @param dist
 */
export declare const extendPointOnLine: (p1: Point, p2: Point, dist: number) => {
    x: number;
    y: number;
};
export interface SubdivideCurveOpts {
    maxLen?: number;
}
/**
 * Break up long segments in the curve into smaller segments of len maxLen or smaller
 * @param curve
 * @param options
 */
export declare const subdivideCurve: (curve: Point[], options?: SubdivideCurveOpts) => Point[];
export interface RebalanceCurveOpts {
    numPoints?: number;
}
/**
 * Redraw the curve using `numPoints` points equally spaced along the length of the curve
 * This may result in a slightly different shape than the original if `numPoints` is low
 * @param curve
 * @param options
 */
export declare const rebalanceCurve: (curve: Point[], options: RebalanceCurveOpts) => Point[];
/**
 * Rotate the curve around the origin
 * @param curve
 * @param theta the angle to rotate by, in radians
 */
export declare const rotateCurve: (curve: Point[], theta: number) => Point[];
