{"version":3,"file":"index.umd.js","sources":["../src/utils.ts","../src/geometry.ts","../src/frechetDistance.ts","../src/procrustesAnalysis.ts","../src/shapeSimilarity.ts"],"sourcesContent":["/** @hidden */\nexport const arrLast = <T>(arr: T[]): T => arr[arr.length - 1];\n\n/** @hidden */\nexport const arrSum = (arr: number[]): number =>\n  arr.reduce((acc, val) => acc + val, 0);\n\n/** @hidden */\nexport const arrAverage = (arr: number[]): number => {\n  const sum = arr.reduce((acc, val) => val + acc, 0);\n  return sum / arr.length;\n};\n","import { arrLast } from './utils';\n\nexport interface Point {\n  x: number;\n  y: number;\n}\n\nexport type Curve = Point[];\n\n/** @hidden */\nexport const subtract = (v1: Point, v2: Point): Point => ({\n  x: v1.x - v2.x,\n  y: v1.y - v2.y\n});\n\nconst magnitude = ({ x, y }: Point) => Math.sqrt(x * x + y * y);\n\n/**\n * Calculate the distance between 2 points\n * @param point1\n * @param point2\n */\nexport const pointDistance = (point1: Point, point2: Point) =>\n  magnitude(subtract(point1, point2));\n\n/**\n * calculate the length of the curve\n * @param points\n */\nexport const curveLength = (points: Curve) => {\n  let lastPoint = points[0];\n  const pointsSansFirst = points.slice(1);\n  return pointsSansFirst.reduce((acc, point) => {\n    const dist = pointDistance(point, lastPoint);\n    lastPoint = point;\n    return acc + dist;\n  }, 0);\n};\n\n/**\n * return a new point, p3, which is on the same line as p1 and p2, but <dist> away from p2\n * p1, p2, p3 will always lie on the line in that order (as long as dist is positive)\n * @param p1\n * @param p2\n * @param dist\n */\nexport const extendPointOnLine = (p1: Point, p2: Point, dist: number) => {\n  const vect = subtract(p2, p1);\n  const norm = dist / magnitude(vect);\n  return { x: p2.x + norm * vect.x, y: p2.y + norm * vect.y };\n};\n\nexport interface SubdivideCurveOpts {\n  maxLen?: number;\n}\n\n/**\n * Break up long segments in the curve into smaller segments of len maxLen or smaller\n * @param curve\n * @param options\n */\nexport const subdivideCurve = (\n  curve: Curve,\n  options: SubdivideCurveOpts = {}\n): Curve => {\n  const { maxLen = 0.05 } = options;\n  const newCurve = curve.slice(0, 1);\n  curve.slice(1).forEach(point => {\n    const prevPoint = newCurve[newCurve.length - 1];\n    const segLen = pointDistance(point, prevPoint);\n    if (segLen > maxLen) {\n      const numNewPoints = Math.ceil(segLen / maxLen);\n      const newSegLen = segLen / numNewPoints;\n      for (let i = 0; i < numNewPoints; i++) {\n        newCurve.push(\n          extendPointOnLine(point, prevPoint, -1 * newSegLen * (i + 1))\n        );\n      }\n    } else {\n      newCurve.push(point);\n    }\n  });\n  return newCurve;\n};\n\nexport interface RebalanceCurveOpts {\n  numPoints?: number;\n}\n\n/**\n * Redraw the curve using `numPoints` points equally spaced along the length of the curve\n * This may result in a slightly different shape than the original if `numPoints` is low\n * @param curve\n * @param options\n */\nexport const rebalanceCurve = (\n  curve: Curve,\n  options: RebalanceCurveOpts\n): Curve => {\n  const { numPoints = 50 } = options;\n  const curveLen = curveLength(curve);\n  const segmentLen = curveLen / (numPoints - 1);\n  const outlinePoints = [curve[0]];\n  const endPoint = arrLast(curve);\n  const remainingCurvePoints = curve.slice(1);\n  for (let i = 0; i < numPoints - 2; i++) {\n    let lastPoint = arrLast(outlinePoints);\n    let remainingDist = segmentLen;\n    let outlinePointFound = false;\n    while (!outlinePointFound) {\n      const nextPointDist = pointDistance(lastPoint, remainingCurvePoints[0]);\n      if (nextPointDist < remainingDist) {\n        remainingDist -= nextPointDist;\n        lastPoint = remainingCurvePoints.shift() as Point;\n      } else {\n        const nextPoint = extendPointOnLine(\n          lastPoint,\n          remainingCurvePoints[0],\n          remainingDist - nextPointDist\n        );\n        outlinePoints.push(nextPoint);\n        outlinePointFound = true;\n      }\n    }\n  }\n  outlinePoints.push(endPoint);\n  return outlinePoints;\n};\n\n/**\n * Rotate the curve around the origin\n * @param curve\n * @param theta the angle to rotate by, in radians\n */\nexport const rotateCurve = (curve: Curve, theta: number): Curve => {\n  return curve.map(point => ({\n    x: Math.cos(-1 * theta) * point.x - Math.sin(-1 * theta) * point.y,\n    y: Math.sin(-1 * theta) * point.x + Math.cos(-1 * theta) * point.y\n  }));\n};\n","import { Curve, pointDistance } from './geometry';\n\n/**\n * Discrete Frechet distance between 2 curves\n * based on http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf\n * modified to be iterative and have better memory usage\n */\nconst frechetDist = (curve1: Curve, curve2: Curve) => {\n  const longCurve = curve1.length >= curve2.length ? curve1 : curve2;\n  const shortCurve = curve1.length >= curve2.length ? curve2 : curve1;\n  const calcVal = (\n    i: number,\n    j: number,\n    prevResultsCol: number[],\n    curResultsCol: number[]\n  ): number => {\n    if (i === 0 && j === 0) {\n      return pointDistance(longCurve[0], shortCurve[0]);\n    }\n    if (i > 0 && j === 0) {\n      return Math.max(\n        prevResultsCol[0],\n        pointDistance(longCurve[i], shortCurve[0])\n      );\n    }\n    const lastResult = curResultsCol[curResultsCol.length - 1];\n    if (i === 0 && j > 0) {\n      return Math.max(lastResult, pointDistance(longCurve[0], shortCurve[j]));\n    }\n\n    return Math.max(\n      Math.min(prevResultsCol[j], prevResultsCol[j - 1], lastResult),\n      pointDistance(longCurve[i], shortCurve[j])\n    );\n  };\n\n  let prevResultsCol: number[] = [];\n  for (let i = 0; i < longCurve.length; i++) {\n    const curResultsCol: number[] = [];\n    for (let j = 0; j < shortCurve.length; j++) {\n      // we only need the results from i - 1 and j - 1 to continue the calculation\n      // so we only need to hold onto the last column of calculated results\n      // prevResultsCol is results[i-1][:] in the original algorithm\n      // curResultsCol is results[i][:j-1] in the original algorithm\n      curResultsCol.push(calcVal(i, j, prevResultsCol, curResultsCol));\n    }\n    prevResultsCol = curResultsCol;\n  }\n\n  return prevResultsCol[shortCurve.length - 1];\n};\n\nexport default frechetDist;\n","import {\n  Curve,\n  Point,\n  rebalanceCurve,\n  rotateCurve,\n  subtract\n} from './geometry';\nimport { arrAverage, arrSum } from './utils';\n\nexport interface ProcrustesNormalizeCurveOpts {\n  rebalance?: boolean;\n  estimationPoints?: number;\n}\n\n/**\n * Translate and scale curve by Procrustes Analysis\n *\n * Optionally runs [[rebalanceCurve]] first (default true)\n * from https://en.wikipedia.org/wiki/Procrustes_analysis\n * @param curve\n * @param options\n */\nexport const procrustesNormalizeCurve = (\n  curve: Curve,\n  options: ProcrustesNormalizeCurveOpts = {}\n): Curve => {\n  const { rebalance = true, estimationPoints = 50 } = options;\n  const balancedCurve = rebalance\n    ? rebalanceCurve(curve, { numPoints: estimationPoints })\n    : curve;\n  const meanX = arrAverage(balancedCurve.map(point => point.x));\n  const meanY = arrAverage(balancedCurve.map(point => point.y));\n  const mean: Point = { x: meanX, y: meanY };\n  const translatedCurve = balancedCurve.map(point => subtract(point, mean));\n  const scale = Math.sqrt(\n    arrAverage(translatedCurve.map(({ x, y }) => x * x + y * y))\n  );\n  return translatedCurve.map(point => ({\n    x: point.x / scale,\n    y: point.y / scale\n  }));\n};\n\n/**\n * Find the angle to rotate `curve` to match the rotation of `relativeCurve` using procrustes analysis\n *\n * from https://en.wikipedia.org/wiki/Procrustes_analysis\n * `curve` and `relativeCurve` must have the same number of points\n * `curve` and `relativeCurve` should both be run through [[procrustesNormalizeCurve]] first\n * @param curve\n * @param relativeCurve\n */\nexport const findProcrustesRotationAngle = (\n  curve: Curve,\n  relativeCurve: Curve\n): number => {\n  if (curve.length !== relativeCurve.length) {\n    throw new Error('curve and relativeCurve must have the same length');\n  }\n\n  const numerator = arrSum(\n    curve.map(({ x, y }, i) => y * relativeCurve[i].x - x * relativeCurve[i].y)\n  );\n  const denominator = arrSum(\n    curve.map(({ x, y }, i) => x * relativeCurve[i].x + y * relativeCurve[i].y)\n  );\n  return Math.atan2(numerator, denominator);\n};\n\n/**\n * Rotate `curve` to match the rotation of `relativeCurve` using procrustes analysis\n *\n * from https://en.wikipedia.org/wiki/Procrustes_analysis\n * `curve` and `relativeCurve` must have the same number of points\n * `curve` and `relativeCurve` should both be run through [[procrustesNormalizeCurve]] first\n * @param curve\n * @param relativeCurve\n */\nexport const procrustesNormalizeRotation = (\n  curve: Curve,\n  relativeCurve: Curve\n): Curve => {\n  const angle = findProcrustesRotationAngle(curve, relativeCurve);\n  return rotateCurve(curve, angle);\n};\n","import frechetDistance from './frechetDistance';\nimport { Curve, curveLength, rotateCurve } from './geometry';\nimport {\n  findProcrustesRotationAngle,\n  procrustesNormalizeCurve\n} from './procrustesAnalysis';\n\nexport interface ShapeSimilarityOpts {\n  estimationPoints?: number;\n  checkRotations?: boolean;\n  rotations?: number;\n  restrictRotationAngle?: number;\n}\n\n/**\n * Estimate how similar the shapes of 2 curves are to each\n * accounting for translation, scale, and rotation\n * @param curve1\n * @param curve2\n * @param options\n * @returns between 1 and 0 depending on how similar the shapes are, where 1 means identical.\n */\nexport const shapeSimilarity = (\n  curve1: Curve,\n  curve2: Curve,\n  options: ShapeSimilarityOpts = {}\n): number => {\n  const {\n    estimationPoints = 50,\n    rotations = 10,\n    restrictRotationAngle = Math.PI,\n    checkRotations = true\n  } = options;\n  if (Math.abs(restrictRotationAngle) > Math.PI) {\n    throw new Error('restrictRotationAngle cannot be larger than PI');\n  }\n  const normalizedCurve1 = procrustesNormalizeCurve(curve1, {\n    estimationPoints\n  });\n  const normalizedCurve2 = procrustesNormalizeCurve(curve2, {\n    estimationPoints\n  });\n\n  const geoAvgCurveLen = Math.sqrt(\n    curveLength(normalizedCurve1) * curveLength(normalizedCurve2)\n  );\n\n  const thetasToCheck = [0];\n\n  if (checkRotations) {\n    let procrustesTheta = findProcrustesRotationAngle(\n      normalizedCurve1,\n      normalizedCurve2\n    );\n    // use a negative rotation rather than a large positive rotation\n    if (procrustesTheta > Math.PI) {\n      procrustesTheta = procrustesTheta - 2 * Math.PI;\n    }\n    if (\n      procrustesTheta !== 0 &&\n      Math.abs(procrustesTheta) < restrictRotationAngle\n    ) {\n      thetasToCheck.push(procrustesTheta);\n    }\n    for (let i = 0; i < rotations; i++) {\n      const theta =\n        -1 * restrictRotationAngle +\n        (2 * i * restrictRotationAngle) / (rotations - 1);\n      // 0 and Math.PI are already being checked, no need to check twice\n      if (theta !== 0 && theta !== Math.PI) {\n        thetasToCheck.push(theta);\n      }\n    }\n  }\n\n  let minFrechetDist = Infinity;\n  // check some other thetas here just in case the procrustes theta isn't the best rotation\n  thetasToCheck.forEach(theta => {\n    const rotatedCurve1 = rotateCurve(normalizedCurve1, theta);\n    const dist = frechetDistance(rotatedCurve1, normalizedCurve2);\n    if (dist < minFrechetDist) minFrechetDist = dist;\n  });\n\n  // divide by Math.sqrt(2) to try to get the low results closer to 0\n  return Math.max(1 - minFrechetDist / (geoAvgCurveLen / Math.sqrt(2)), 0);\n};\n\nexport default shapeSimilarity;\n"],"names":["frechetDistance"],"mappings":"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"}