/** @hidden */
var arrLast = function (arr) { return arr[arr.length - 1]; };
/** @hidden */
var arrSum = function (arr) {
    return arr.reduce(function (acc, val) { return acc + val; }, 0);
};
/** @hidden */
var arrAverage = function (arr) {
    var sum = arr.reduce(function (acc, val) { return val + acc; }, 0);
    return sum / arr.length;
};

/** @hidden */
var subtract = function (v1, v2) { return ({
    x: v1.x - v2.x,
    y: v1.y - v2.y
}); };
var magnitude = function (_a) {
    var x = _a.x, y = _a.y;
    return Math.sqrt(x * x + y * y);
};
/**
 * Calculate the distance between 2 points
 * @param point1
 * @param point2
 */
var pointDistance = function (point1, point2) {
    return magnitude(subtract(point1, point2));
};
/**
 * calculate the length of the curve
 * @param points
 */
var curveLength = function (points) {
    var lastPoint = points[0];
    var pointsSansFirst = points.slice(1);
    return pointsSansFirst.reduce(function (acc, point) {
        var dist = pointDistance(point, lastPoint);
        lastPoint = point;
        return acc + dist;
    }, 0);
};
/**
 * return a new point, p3, which is on the same line as p1 and p2, but <dist> away from p2
 * p1, p2, p3 will always lie on the line in that order (as long as dist is positive)
 * @param p1
 * @param p2
 * @param dist
 */
var extendPointOnLine = function (p1, p2, dist) {
    var vect = subtract(p2, p1);
    var norm = dist / magnitude(vect);
    return { x: p2.x + norm * vect.x, y: p2.y + norm * vect.y };
};
/**
 * Break up long segments in the curve into smaller segments of len maxLen or smaller
 * @param curve
 * @param options
 */
var subdivideCurve = function (curve, options) {
    if (options === void 0) { options = {}; }
    var _a = options.maxLen, maxLen = _a === void 0 ? 0.05 : _a;
    var newCurve = curve.slice(0, 1);
    curve.slice(1).forEach(function (point) {
        var prevPoint = newCurve[newCurve.length - 1];
        var segLen = pointDistance(point, prevPoint);
        if (segLen > maxLen) {
            var numNewPoints = Math.ceil(segLen / maxLen);
            var newSegLen = segLen / numNewPoints;
            for (var i = 0; i < numNewPoints; i++) {
                newCurve.push(extendPointOnLine(point, prevPoint, -1 * newSegLen * (i + 1)));
            }
        }
        else {
            newCurve.push(point);
        }
    });
    return newCurve;
};
/**
 * Redraw the curve using `numPoints` points equally spaced along the length of the curve
 * This may result in a slightly different shape than the original if `numPoints` is low
 * @param curve
 * @param options
 */
var rebalanceCurve = function (curve, options) {
    var _a = options.numPoints, numPoints = _a === void 0 ? 50 : _a;
    var curveLen = curveLength(curve);
    var segmentLen = curveLen / (numPoints - 1);
    var outlinePoints = [curve[0]];
    var endPoint = arrLast(curve);
    var remainingCurvePoints = curve.slice(1);
    for (var i = 0; i < numPoints - 2; i++) {
        var lastPoint = arrLast(outlinePoints);
        var remainingDist = segmentLen;
        var outlinePointFound = false;
        while (!outlinePointFound) {
            var nextPointDist = pointDistance(lastPoint, remainingCurvePoints[0]);
            if (nextPointDist < remainingDist) {
                remainingDist -= nextPointDist;
                lastPoint = remainingCurvePoints.shift();
            }
            else {
                var nextPoint = extendPointOnLine(lastPoint, remainingCurvePoints[0], remainingDist - nextPointDist);
                outlinePoints.push(nextPoint);
                outlinePointFound = true;
            }
        }
    }
    outlinePoints.push(endPoint);
    return outlinePoints;
};
/**
 * Rotate the curve around the origin
 * @param curve
 * @param theta the angle to rotate by, in radians
 */
var rotateCurve = function (curve, theta) {
    return curve.map(function (point) { return ({
        x: Math.cos(-1 * theta) * point.x - Math.sin(-1 * theta) * point.y,
        y: Math.sin(-1 * theta) * point.x + Math.cos(-1 * theta) * point.y
    }); });
};

/**
 * Discrete Frechet distance between 2 curves
 * based on http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf
 * modified to be iterative and have better memory usage
 */
var frechetDist = function (curve1, curve2) {
    var longCurve = curve1.length >= curve2.length ? curve1 : curve2;
    var shortCurve = curve1.length >= curve2.length ? curve2 : curve1;
    var calcVal = function (i, j, prevResultsCol, curResultsCol) {
        if (i === 0 && j === 0) {
            return pointDistance(longCurve[0], shortCurve[0]);
        }
        if (i > 0 && j === 0) {
            return Math.max(prevResultsCol[0], pointDistance(longCurve[i], shortCurve[0]));
        }
        var lastResult = curResultsCol[curResultsCol.length - 1];
        if (i === 0 && j > 0) {
            return Math.max(lastResult, pointDistance(longCurve[0], shortCurve[j]));
        }
        return Math.max(Math.min(prevResultsCol[j], prevResultsCol[j - 1], lastResult), pointDistance(longCurve[i], shortCurve[j]));
    };
    var prevResultsCol = [];
    for (var i = 0; i < longCurve.length; i++) {
        var curResultsCol = [];
        for (var j = 0; j < shortCurve.length; j++) {
            // we only need the results from i - 1 and j - 1 to continue the calculation
            // so we only need to hold onto the last column of calculated results
            // prevResultsCol is results[i-1][:] in the original algorithm
            // curResultsCol is results[i][:j-1] in the original algorithm
            curResultsCol.push(calcVal(i, j, prevResultsCol, curResultsCol));
        }
        prevResultsCol = curResultsCol;
    }
    return prevResultsCol[shortCurve.length - 1];
};

/**
 * Translate and scale curve by Procrustes Analysis
 *
 * Optionally runs [[rebalanceCurve]] first (default true)
 * from https://en.wikipedia.org/wiki/Procrustes_analysis
 * @param curve
 * @param options
 */
var procrustesNormalizeCurve = function (curve, options) {
    if (options === void 0) { options = {}; }
    var _a = options.rebalance, rebalance = _a === void 0 ? true : _a, _b = options.estimationPoints, estimationPoints = _b === void 0 ? 50 : _b;
    var balancedCurve = rebalance
        ? rebalanceCurve(curve, { numPoints: estimationPoints })
        : curve;
    var meanX = arrAverage(balancedCurve.map(function (point) { return point.x; }));
    var meanY = arrAverage(balancedCurve.map(function (point) { return point.y; }));
    var mean = { x: meanX, y: meanY };
    var translatedCurve = balancedCurve.map(function (point) { return subtract(point, mean); });
    var scale = Math.sqrt(arrAverage(translatedCurve.map(function (_a) {
        var x = _a.x, y = _a.y;
        return x * x + y * y;
    })));
    return translatedCurve.map(function (point) { return ({
        x: point.x / scale,
        y: point.y / scale
    }); });
};
/**
 * Find the angle to rotate `curve` to match the rotation of `relativeCurve` using procrustes analysis
 *
 * from https://en.wikipedia.org/wiki/Procrustes_analysis
 * `curve` and `relativeCurve` must have the same number of points
 * `curve` and `relativeCurve` should both be run through [[procrustesNormalizeCurve]] first
 * @param curve
 * @param relativeCurve
 */
var findProcrustesRotationAngle = function (curve, relativeCurve) {
    if (curve.length !== relativeCurve.length) {
        throw new Error('curve and relativeCurve must have the same length');
    }
    var numerator = arrSum(curve.map(function (_a, i) {
        var x = _a.x, y = _a.y;
        return y * relativeCurve[i].x - x * relativeCurve[i].y;
    }));
    var denominator = arrSum(curve.map(function (_a, i) {
        var x = _a.x, y = _a.y;
        return x * relativeCurve[i].x + y * relativeCurve[i].y;
    }));
    return Math.atan2(numerator, denominator);
};
/**
 * Rotate `curve` to match the rotation of `relativeCurve` using procrustes analysis
 *
 * from https://en.wikipedia.org/wiki/Procrustes_analysis
 * `curve` and `relativeCurve` must have the same number of points
 * `curve` and `relativeCurve` should both be run through [[procrustesNormalizeCurve]] first
 * @param curve
 * @param relativeCurve
 */
var procrustesNormalizeRotation = function (curve, relativeCurve) {
    var angle = findProcrustesRotationAngle(curve, relativeCurve);
    return rotateCurve(curve, angle);
};

/**
 * Estimate how similar the shapes of 2 curves are to each
 * accounting for translation, scale, and rotation
 * @param curve1
 * @param curve2
 * @param options
 * @returns between 1 and 0 depending on how similar the shapes are, where 1 means identical.
 */
var shapeSimilarity = function (curve1, curve2, options) {
    if (options === void 0) { options = {}; }
    var _a = options.estimationPoints, estimationPoints = _a === void 0 ? 50 : _a, _b = options.rotations, rotations = _b === void 0 ? 10 : _b, _c = options.restrictRotationAngle, restrictRotationAngle = _c === void 0 ? Math.PI : _c, _d = options.checkRotations, checkRotations = _d === void 0 ? true : _d;
    if (Math.abs(restrictRotationAngle) > Math.PI) {
        throw new Error('restrictRotationAngle cannot be larger than PI');
    }
    var normalizedCurve1 = procrustesNormalizeCurve(curve1, {
        estimationPoints: estimationPoints
    });
    var normalizedCurve2 = procrustesNormalizeCurve(curve2, {
        estimationPoints: estimationPoints
    });
    var geoAvgCurveLen = Math.sqrt(curveLength(normalizedCurve1) * curveLength(normalizedCurve2));
    var thetasToCheck = [0];
    if (checkRotations) {
        var procrustesTheta = findProcrustesRotationAngle(normalizedCurve1, normalizedCurve2);
        // use a negative rotation rather than a large positive rotation
        if (procrustesTheta > Math.PI) {
            procrustesTheta = procrustesTheta - 2 * Math.PI;
        }
        if (procrustesTheta !== 0 &&
            Math.abs(procrustesTheta) < restrictRotationAngle) {
            thetasToCheck.push(procrustesTheta);
        }
        for (var i = 0; i < rotations; i++) {
            var theta = -1 * restrictRotationAngle +
                (2 * i * restrictRotationAngle) / (rotations - 1);
            // 0 and Math.PI are already being checked, no need to check twice
            if (theta !== 0 && theta !== Math.PI) {
                thetasToCheck.push(theta);
            }
        }
    }
    var minFrechetDist = Infinity;
    // check some other thetas here just in case the procrustes theta isn't the best rotation
    thetasToCheck.forEach(function (theta) {
        var rotatedCurve1 = rotateCurve(normalizedCurve1, theta);
        var dist = frechetDist(rotatedCurve1, normalizedCurve2);
        if (dist < minFrechetDist)
            minFrechetDist = dist;
    });
    // divide by Math.sqrt(2) to try to get the low results closer to 0
    return Math.max(1 - minFrechetDist / (geoAvgCurveLen / Math.sqrt(2)), 0);
};

export { curveLength, pointDistance, extendPointOnLine, subdivideCurve, rebalanceCurve, rotateCurve, frechetDist as frechetDistance, procrustesNormalizeRotation, procrustesNormalizeCurve, findProcrustesRotationAngle, shapeSimilarity };
//# sourceMappingURL=index.es5.js.map
