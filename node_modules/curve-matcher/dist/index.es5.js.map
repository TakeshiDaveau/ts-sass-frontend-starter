{"version":3,"file":"index.es5.js","sources":["../src/utils.ts","../src/geometry.ts","../src/frechetDistance.ts","../src/procrustesAnalysis.ts","../src/shapeSimilarity.ts"],"sourcesContent":["/** @hidden */\nexport const arrLast = <T>(arr: T[]): T => arr[arr.length - 1];\n\n/** @hidden */\nexport const arrSum = (arr: number[]): number =>\n  arr.reduce((acc, val) => acc + val, 0);\n\n/** @hidden */\nexport const arrAverage = (arr: number[]): number => {\n  const sum = arr.reduce((acc, val) => val + acc, 0);\n  return sum / arr.length;\n};\n","import { arrLast } from './utils';\n\nexport interface Point {\n  x: number;\n  y: number;\n}\n\nexport type Curve = Point[];\n\n/** @hidden */\nexport const subtract = (v1: Point, v2: Point): Point => ({\n  x: v1.x - v2.x,\n  y: v1.y - v2.y\n});\n\nconst magnitude = ({ x, y }: Point) => Math.sqrt(x * x + y * y);\n\n/**\n * Calculate the distance between 2 points\n * @param point1\n * @param point2\n */\nexport const pointDistance = (point1: Point, point2: Point) =>\n  magnitude(subtract(point1, point2));\n\n/**\n * calculate the length of the curve\n * @param points\n */\nexport const curveLength = (points: Curve) => {\n  let lastPoint = points[0];\n  const pointsSansFirst = points.slice(1);\n  return pointsSansFirst.reduce((acc, point) => {\n    const dist = pointDistance(point, lastPoint);\n    lastPoint = point;\n    return acc + dist;\n  }, 0);\n};\n\n/**\n * return a new point, p3, which is on the same line as p1 and p2, but <dist> away from p2\n * p1, p2, p3 will always lie on the line in that order (as long as dist is positive)\n * @param p1\n * @param p2\n * @param dist\n */\nexport const extendPointOnLine = (p1: Point, p2: Point, dist: number) => {\n  const vect = subtract(p2, p1);\n  const norm = dist / magnitude(vect);\n  return { x: p2.x + norm * vect.x, y: p2.y + norm * vect.y };\n};\n\nexport interface SubdivideCurveOpts {\n  maxLen?: number;\n}\n\n/**\n * Break up long segments in the curve into smaller segments of len maxLen or smaller\n * @param curve\n * @param options\n */\nexport const subdivideCurve = (\n  curve: Curve,\n  options: SubdivideCurveOpts = {}\n): Curve => {\n  const { maxLen = 0.05 } = options;\n  const newCurve = curve.slice(0, 1);\n  curve.slice(1).forEach(point => {\n    const prevPoint = newCurve[newCurve.length - 1];\n    const segLen = pointDistance(point, prevPoint);\n    if (segLen > maxLen) {\n      const numNewPoints = Math.ceil(segLen / maxLen);\n      const newSegLen = segLen / numNewPoints;\n      for (let i = 0; i < numNewPoints; i++) {\n        newCurve.push(\n          extendPointOnLine(point, prevPoint, -1 * newSegLen * (i + 1))\n        );\n      }\n    } else {\n      newCurve.push(point);\n    }\n  });\n  return newCurve;\n};\n\nexport interface RebalanceCurveOpts {\n  numPoints?: number;\n}\n\n/**\n * Redraw the curve using `numPoints` points equally spaced along the length of the curve\n * This may result in a slightly different shape than the original if `numPoints` is low\n * @param curve\n * @param options\n */\nexport const rebalanceCurve = (\n  curve: Curve,\n  options: RebalanceCurveOpts\n): Curve => {\n  const { numPoints = 50 } = options;\n  const curveLen = curveLength(curve);\n  const segmentLen = curveLen / (numPoints - 1);\n  const outlinePoints = [curve[0]];\n  const endPoint = arrLast(curve);\n  const remainingCurvePoints = curve.slice(1);\n  for (let i = 0; i < numPoints - 2; i++) {\n    let lastPoint = arrLast(outlinePoints);\n    let remainingDist = segmentLen;\n    let outlinePointFound = false;\n    while (!outlinePointFound) {\n      const nextPointDist = pointDistance(lastPoint, remainingCurvePoints[0]);\n      if (nextPointDist < remainingDist) {\n        remainingDist -= nextPointDist;\n        lastPoint = remainingCurvePoints.shift() as Point;\n      } else {\n        const nextPoint = extendPointOnLine(\n          lastPoint,\n          remainingCurvePoints[0],\n          remainingDist - nextPointDist\n        );\n        outlinePoints.push(nextPoint);\n        outlinePointFound = true;\n      }\n    }\n  }\n  outlinePoints.push(endPoint);\n  return outlinePoints;\n};\n\n/**\n * Rotate the curve around the origin\n * @param curve\n * @param theta the angle to rotate by, in radians\n */\nexport const rotateCurve = (curve: Curve, theta: number): Curve => {\n  return curve.map(point => ({\n    x: Math.cos(-1 * theta) * point.x - Math.sin(-1 * theta) * point.y,\n    y: Math.sin(-1 * theta) * point.x + Math.cos(-1 * theta) * point.y\n  }));\n};\n","import { Curve, pointDistance } from './geometry';\n\n/**\n * Discrete Frechet distance between 2 curves\n * based on http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf\n * modified to be iterative and have better memory usage\n */\nconst frechetDist = (curve1: Curve, curve2: Curve) => {\n  const longCurve = curve1.length >= curve2.length ? curve1 : curve2;\n  const shortCurve = curve1.length >= curve2.length ? curve2 : curve1;\n  const calcVal = (\n    i: number,\n    j: number,\n    prevResultsCol: number[],\n    curResultsCol: number[]\n  ): number => {\n    if (i === 0 && j === 0) {\n      return pointDistance(longCurve[0], shortCurve[0]);\n    }\n    if (i > 0 && j === 0) {\n      return Math.max(\n        prevResultsCol[0],\n        pointDistance(longCurve[i], shortCurve[0])\n      );\n    }\n    const lastResult = curResultsCol[curResultsCol.length - 1];\n    if (i === 0 && j > 0) {\n      return Math.max(lastResult, pointDistance(longCurve[0], shortCurve[j]));\n    }\n\n    return Math.max(\n      Math.min(prevResultsCol[j], prevResultsCol[j - 1], lastResult),\n      pointDistance(longCurve[i], shortCurve[j])\n    );\n  };\n\n  let prevResultsCol: number[] = [];\n  for (let i = 0; i < longCurve.length; i++) {\n    const curResultsCol: number[] = [];\n    for (let j = 0; j < shortCurve.length; j++) {\n      // we only need the results from i - 1 and j - 1 to continue the calculation\n      // so we only need to hold onto the last column of calculated results\n      // prevResultsCol is results[i-1][:] in the original algorithm\n      // curResultsCol is results[i][:j-1] in the original algorithm\n      curResultsCol.push(calcVal(i, j, prevResultsCol, curResultsCol));\n    }\n    prevResultsCol = curResultsCol;\n  }\n\n  return prevResultsCol[shortCurve.length - 1];\n};\n\nexport default frechetDist;\n","import {\n  Curve,\n  Point,\n  rebalanceCurve,\n  rotateCurve,\n  subtract\n} from './geometry';\nimport { arrAverage, arrSum } from './utils';\n\nexport interface ProcrustesNormalizeCurveOpts {\n  rebalance?: boolean;\n  estimationPoints?: number;\n}\n\n/**\n * Translate and scale curve by Procrustes Analysis\n *\n * Optionally runs [[rebalanceCurve]] first (default true)\n * from https://en.wikipedia.org/wiki/Procrustes_analysis\n * @param curve\n * @param options\n */\nexport const procrustesNormalizeCurve = (\n  curve: Curve,\n  options: ProcrustesNormalizeCurveOpts = {}\n): Curve => {\n  const { rebalance = true, estimationPoints = 50 } = options;\n  const balancedCurve = rebalance\n    ? rebalanceCurve(curve, { numPoints: estimationPoints })\n    : curve;\n  const meanX = arrAverage(balancedCurve.map(point => point.x));\n  const meanY = arrAverage(balancedCurve.map(point => point.y));\n  const mean: Point = { x: meanX, y: meanY };\n  const translatedCurve = balancedCurve.map(point => subtract(point, mean));\n  const scale = Math.sqrt(\n    arrAverage(translatedCurve.map(({ x, y }) => x * x + y * y))\n  );\n  return translatedCurve.map(point => ({\n    x: point.x / scale,\n    y: point.y / scale\n  }));\n};\n\n/**\n * Find the angle to rotate `curve` to match the rotation of `relativeCurve` using procrustes analysis\n *\n * from https://en.wikipedia.org/wiki/Procrustes_analysis\n * `curve` and `relativeCurve` must have the same number of points\n * `curve` and `relativeCurve` should both be run through [[procrustesNormalizeCurve]] first\n * @param curve\n * @param relativeCurve\n */\nexport const findProcrustesRotationAngle = (\n  curve: Curve,\n  relativeCurve: Curve\n): number => {\n  if (curve.length !== relativeCurve.length) {\n    throw new Error('curve and relativeCurve must have the same length');\n  }\n\n  const numerator = arrSum(\n    curve.map(({ x, y }, i) => y * relativeCurve[i].x - x * relativeCurve[i].y)\n  );\n  const denominator = arrSum(\n    curve.map(({ x, y }, i) => x * relativeCurve[i].x + y * relativeCurve[i].y)\n  );\n  return Math.atan2(numerator, denominator);\n};\n\n/**\n * Rotate `curve` to match the rotation of `relativeCurve` using procrustes analysis\n *\n * from https://en.wikipedia.org/wiki/Procrustes_analysis\n * `curve` and `relativeCurve` must have the same number of points\n * `curve` and `relativeCurve` should both be run through [[procrustesNormalizeCurve]] first\n * @param curve\n * @param relativeCurve\n */\nexport const procrustesNormalizeRotation = (\n  curve: Curve,\n  relativeCurve: Curve\n): Curve => {\n  const angle = findProcrustesRotationAngle(curve, relativeCurve);\n  return rotateCurve(curve, angle);\n};\n","import frechetDistance from './frechetDistance';\nimport { Curve, curveLength, rotateCurve } from './geometry';\nimport {\n  findProcrustesRotationAngle,\n  procrustesNormalizeCurve\n} from './procrustesAnalysis';\n\nexport interface ShapeSimilarityOpts {\n  estimationPoints?: number;\n  checkRotations?: boolean;\n  rotations?: number;\n  restrictRotationAngle?: number;\n}\n\n/**\n * Estimate how similar the shapes of 2 curves are to each\n * accounting for translation, scale, and rotation\n * @param curve1\n * @param curve2\n * @param options\n * @returns between 1 and 0 depending on how similar the shapes are, where 1 means identical.\n */\nexport const shapeSimilarity = (\n  curve1: Curve,\n  curve2: Curve,\n  options: ShapeSimilarityOpts = {}\n): number => {\n  const {\n    estimationPoints = 50,\n    rotations = 10,\n    restrictRotationAngle = Math.PI,\n    checkRotations = true\n  } = options;\n  if (Math.abs(restrictRotationAngle) > Math.PI) {\n    throw new Error('restrictRotationAngle cannot be larger than PI');\n  }\n  const normalizedCurve1 = procrustesNormalizeCurve(curve1, {\n    estimationPoints\n  });\n  const normalizedCurve2 = procrustesNormalizeCurve(curve2, {\n    estimationPoints\n  });\n\n  const geoAvgCurveLen = Math.sqrt(\n    curveLength(normalizedCurve1) * curveLength(normalizedCurve2)\n  );\n\n  const thetasToCheck = [0];\n\n  if (checkRotations) {\n    let procrustesTheta = findProcrustesRotationAngle(\n      normalizedCurve1,\n      normalizedCurve2\n    );\n    // use a negative rotation rather than a large positive rotation\n    if (procrustesTheta > Math.PI) {\n      procrustesTheta = procrustesTheta - 2 * Math.PI;\n    }\n    if (\n      procrustesTheta !== 0 &&\n      Math.abs(procrustesTheta) < restrictRotationAngle\n    ) {\n      thetasToCheck.push(procrustesTheta);\n    }\n    for (let i = 0; i < rotations; i++) {\n      const theta =\n        -1 * restrictRotationAngle +\n        (2 * i * restrictRotationAngle) / (rotations - 1);\n      // 0 and Math.PI are already being checked, no need to check twice\n      if (theta !== 0 && theta !== Math.PI) {\n        thetasToCheck.push(theta);\n      }\n    }\n  }\n\n  let minFrechetDist = Infinity;\n  // check some other thetas here just in case the procrustes theta isn't the best rotation\n  thetasToCheck.forEach(theta => {\n    const rotatedCurve1 = rotateCurve(normalizedCurve1, theta);\n    const dist = frechetDistance(rotatedCurve1, normalizedCurve2);\n    if (dist < minFrechetDist) minFrechetDist = dist;\n  });\n\n  // divide by Math.sqrt(2) to try to get the low results closer to 0\n  return Math.max(1 - minFrechetDist / (geoAvgCurveLen / Math.sqrt(2)), 0);\n};\n\nexport default shapeSimilarity;\n"],"names":["frechetDistance"],"mappings":"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"}