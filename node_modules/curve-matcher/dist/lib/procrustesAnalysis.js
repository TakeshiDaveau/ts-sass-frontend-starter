"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var geometry_1 = require("./geometry");
var utils_1 = require("./utils");
/**
 * Translate and scale curve by Procrustes Analysis
 *
 * Optionally runs [[rebalanceCurve]] first (default true)
 * from https://en.wikipedia.org/wiki/Procrustes_analysis
 * @param curve
 * @param options
 */
exports.procrustesNormalizeCurve = function (curve, options) {
    if (options === void 0) { options = {}; }
    var _a = options.rebalance, rebalance = _a === void 0 ? true : _a, _b = options.estimationPoints, estimationPoints = _b === void 0 ? 50 : _b;
    var balancedCurve = rebalance
        ? geometry_1.rebalanceCurve(curve, { numPoints: estimationPoints })
        : curve;
    var meanX = utils_1.arrAverage(balancedCurve.map(function (point) { return point.x; }));
    var meanY = utils_1.arrAverage(balancedCurve.map(function (point) { return point.y; }));
    var mean = { x: meanX, y: meanY };
    var translatedCurve = balancedCurve.map(function (point) { return geometry_1.subtract(point, mean); });
    var scale = Math.sqrt(utils_1.arrAverage(translatedCurve.map(function (_a) {
        var x = _a.x, y = _a.y;
        return x * x + y * y;
    })));
    return translatedCurve.map(function (point) { return ({
        x: point.x / scale,
        y: point.y / scale
    }); });
};
/**
 * Find the angle to rotate `curve` to match the rotation of `relativeCurve` using procrustes analysis
 *
 * from https://en.wikipedia.org/wiki/Procrustes_analysis
 * `curve` and `relativeCurve` must have the same number of points
 * `curve` and `relativeCurve` should both be run through [[procrustesNormalizeCurve]] first
 * @param curve
 * @param relativeCurve
 */
exports.findProcrustesRotationAngle = function (curve, relativeCurve) {
    if (curve.length !== relativeCurve.length) {
        throw new Error('curve and relativeCurve must have the same length');
    }
    var numerator = utils_1.arrSum(curve.map(function (_a, i) {
        var x = _a.x, y = _a.y;
        return y * relativeCurve[i].x - x * relativeCurve[i].y;
    }));
    var denominator = utils_1.arrSum(curve.map(function (_a, i) {
        var x = _a.x, y = _a.y;
        return x * relativeCurve[i].x + y * relativeCurve[i].y;
    }));
    return Math.atan2(numerator, denominator);
};
/**
 * Rotate `curve` to match the rotation of `relativeCurve` using procrustes analysis
 *
 * from https://en.wikipedia.org/wiki/Procrustes_analysis
 * `curve` and `relativeCurve` must have the same number of points
 * `curve` and `relativeCurve` should both be run through [[procrustesNormalizeCurve]] first
 * @param curve
 * @param relativeCurve
 */
exports.procrustesNormalizeRotation = function (curve, relativeCurve) {
    var angle = exports.findProcrustesRotationAngle(curve, relativeCurve);
    return geometry_1.rotateCurve(curve, angle);
};
//# sourceMappingURL=procrustesAnalysis.js.map