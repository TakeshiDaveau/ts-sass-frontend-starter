"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
/** @hidden */
exports.subtract = function (v1, v2) { return ({
    x: v1.x - v2.x,
    y: v1.y - v2.y
}); };
var magnitude = function (_a) {
    var x = _a.x, y = _a.y;
    return Math.sqrt(x * x + y * y);
};
/**
 * Calculate the distance between 2 points
 * @param point1
 * @param point2
 */
exports.pointDistance = function (point1, point2) {
    return magnitude(exports.subtract(point1, point2));
};
/**
 * calculate the length of the curve
 * @param points
 */
exports.curveLength = function (points) {
    var lastPoint = points[0];
    var pointsSansFirst = points.slice(1);
    return pointsSansFirst.reduce(function (acc, point) {
        var dist = exports.pointDistance(point, lastPoint);
        lastPoint = point;
        return acc + dist;
    }, 0);
};
/**
 * return a new point, p3, which is on the same line as p1 and p2, but <dist> away from p2
 * p1, p2, p3 will always lie on the line in that order (as long as dist is positive)
 * @param p1
 * @param p2
 * @param dist
 */
exports.extendPointOnLine = function (p1, p2, dist) {
    var vect = exports.subtract(p2, p1);
    var norm = dist / magnitude(vect);
    return { x: p2.x + norm * vect.x, y: p2.y + norm * vect.y };
};
/**
 * Break up long segments in the curve into smaller segments of len maxLen or smaller
 * @param curve
 * @param options
 */
exports.subdivideCurve = function (curve, options) {
    if (options === void 0) { options = {}; }
    var _a = options.maxLen, maxLen = _a === void 0 ? 0.05 : _a;
    var newCurve = curve.slice(0, 1);
    curve.slice(1).forEach(function (point) {
        var prevPoint = newCurve[newCurve.length - 1];
        var segLen = exports.pointDistance(point, prevPoint);
        if (segLen > maxLen) {
            var numNewPoints = Math.ceil(segLen / maxLen);
            var newSegLen = segLen / numNewPoints;
            for (var i = 0; i < numNewPoints; i++) {
                newCurve.push(exports.extendPointOnLine(point, prevPoint, -1 * newSegLen * (i + 1)));
            }
        }
        else {
            newCurve.push(point);
        }
    });
    return newCurve;
};
/**
 * Redraw the curve using `numPoints` points equally spaced along the length of the curve
 * This may result in a slightly different shape than the original if `numPoints` is low
 * @param curve
 * @param options
 */
exports.rebalanceCurve = function (curve, options) {
    var _a = options.numPoints, numPoints = _a === void 0 ? 50 : _a;
    var curveLen = exports.curveLength(curve);
    var segmentLen = curveLen / (numPoints - 1);
    var outlinePoints = [curve[0]];
    var endPoint = utils_1.arrLast(curve);
    var remainingCurvePoints = curve.slice(1);
    for (var i = 0; i < numPoints - 2; i++) {
        var lastPoint = utils_1.arrLast(outlinePoints);
        var remainingDist = segmentLen;
        var outlinePointFound = false;
        while (!outlinePointFound) {
            var nextPointDist = exports.pointDistance(lastPoint, remainingCurvePoints[0]);
            if (nextPointDist < remainingDist) {
                remainingDist -= nextPointDist;
                lastPoint = remainingCurvePoints.shift();
            }
            else {
                var nextPoint = exports.extendPointOnLine(lastPoint, remainingCurvePoints[0], remainingDist - nextPointDist);
                outlinePoints.push(nextPoint);
                outlinePointFound = true;
            }
        }
    }
    outlinePoints.push(endPoint);
    return outlinePoints;
};
/**
 * Rotate the curve around the origin
 * @param curve
 * @param theta the angle to rotate by, in radians
 */
exports.rotateCurve = function (curve, theta) {
    return curve.map(function (point) { return ({
        x: Math.cos(-1 * theta) * point.x - Math.sin(-1 * theta) * point.y,
        y: Math.sin(-1 * theta) * point.x + Math.cos(-1 * theta) * point.y
    }); });
};
//# sourceMappingURL=geometry.js.map