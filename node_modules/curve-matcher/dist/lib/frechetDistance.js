"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var geometry_1 = require("./geometry");
/**
 * Discrete Frechet distance between 2 curves
 * based on http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf
 * modified to be iterative and have better memory usage
 */
var frechetDist = function (curve1, curve2) {
    var longCurve = curve1.length >= curve2.length ? curve1 : curve2;
    var shortCurve = curve1.length >= curve2.length ? curve2 : curve1;
    var calcVal = function (i, j, prevResultsCol, curResultsCol) {
        if (i === 0 && j === 0) {
            return geometry_1.pointDistance(longCurve[0], shortCurve[0]);
        }
        if (i > 0 && j === 0) {
            return Math.max(prevResultsCol[0], geometry_1.pointDistance(longCurve[i], shortCurve[0]));
        }
        var lastResult = curResultsCol[curResultsCol.length - 1];
        if (i === 0 && j > 0) {
            return Math.max(lastResult, geometry_1.pointDistance(longCurve[0], shortCurve[j]));
        }
        return Math.max(Math.min(prevResultsCol[j], prevResultsCol[j - 1], lastResult), geometry_1.pointDistance(longCurve[i], shortCurve[j]));
    };
    var prevResultsCol = [];
    for (var i = 0; i < longCurve.length; i++) {
        var curResultsCol = [];
        for (var j = 0; j < shortCurve.length; j++) {
            // we only need the results from i - 1 and j - 1 to continue the calculation
            // so we only need to hold onto the last column of calculated results
            // prevResultsCol is results[i-1][:] in the original algorithm
            // curResultsCol is results[i][:j-1] in the original algorithm
            curResultsCol.push(calcVal(i, j, prevResultsCol, curResultsCol));
        }
        prevResultsCol = curResultsCol;
    }
    return prevResultsCol[shortCurve.length - 1];
};
exports.default = frechetDist;
//# sourceMappingURL=frechetDistance.js.map