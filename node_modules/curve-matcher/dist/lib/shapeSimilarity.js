"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var frechetDistance_1 = require("./frechetDistance");
var geometry_1 = require("./geometry");
var procrustesAnalysis_1 = require("./procrustesAnalysis");
/**
 * Estimate how similar the shapes of 2 curves are to each
 * accounting for translation, scale, and rotation
 * @param curve1
 * @param curve2
 * @param options
 * @returns between 1 and 0 depending on how similar the shapes are, where 1 means identical.
 */
exports.shapeSimilarity = function (curve1, curve2, options) {
    if (options === void 0) { options = {}; }
    var _a = options.estimationPoints, estimationPoints = _a === void 0 ? 50 : _a, _b = options.rotations, rotations = _b === void 0 ? 10 : _b, _c = options.restrictRotationAngle, restrictRotationAngle = _c === void 0 ? Math.PI : _c, _d = options.checkRotations, checkRotations = _d === void 0 ? true : _d;
    if (Math.abs(restrictRotationAngle) > Math.PI) {
        throw new Error('restrictRotationAngle cannot be larger than PI');
    }
    var normalizedCurve1 = procrustesAnalysis_1.procrustesNormalizeCurve(curve1, {
        estimationPoints: estimationPoints
    });
    var normalizedCurve2 = procrustesAnalysis_1.procrustesNormalizeCurve(curve2, {
        estimationPoints: estimationPoints
    });
    var geoAvgCurveLen = Math.sqrt(geometry_1.curveLength(normalizedCurve1) * geometry_1.curveLength(normalizedCurve2));
    var thetasToCheck = [0];
    if (checkRotations) {
        var procrustesTheta = procrustesAnalysis_1.findProcrustesRotationAngle(normalizedCurve1, normalizedCurve2);
        // use a negative rotation rather than a large positive rotation
        if (procrustesTheta > Math.PI) {
            procrustesTheta = procrustesTheta - 2 * Math.PI;
        }
        if (procrustesTheta !== 0 &&
            Math.abs(procrustesTheta) < restrictRotationAngle) {
            thetasToCheck.push(procrustesTheta);
        }
        for (var i = 0; i < rotations; i++) {
            var theta = -1 * restrictRotationAngle +
                (2 * i * restrictRotationAngle) / (rotations - 1);
            // 0 and Math.PI are already being checked, no need to check twice
            if (theta !== 0 && theta !== Math.PI) {
                thetasToCheck.push(theta);
            }
        }
    }
    var minFrechetDist = Infinity;
    // check some other thetas here just in case the procrustes theta isn't the best rotation
    thetasToCheck.forEach(function (theta) {
        var rotatedCurve1 = geometry_1.rotateCurve(normalizedCurve1, theta);
        var dist = frechetDistance_1.default(rotatedCurve1, normalizedCurve2);
        if (dist < minFrechetDist)
            minFrechetDist = dist;
    });
    // divide by Math.sqrt(2) to try to get the low results closer to 0
    return Math.max(1 - minFrechetDist / (geoAvgCurveLen / Math.sqrt(2)), 0);
};
exports.default = exports.shapeSimilarity;
//# sourceMappingURL=shapeSimilarity.js.map